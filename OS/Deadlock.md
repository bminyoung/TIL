

# Deadlock

> 교착상태
>
> 대기중인 프로세스가 요청한 자원들이 `다른 대기중인 프로세스`에 의해서 점유되어 있기 때문에 프로세스 상태를 변경시킬 수 없는 상태
>
> "두 기차가 교차로에서 서로 접근할 때, 둘 다 정지해야하며 상대방이 없어지지 않으면 누구도 다시 출발할 수 없음"

## 1. 시스템 모델

> 시스템은 경쟁하는 스레드에 분배돼야 할 유한한 자원들로 구성

- mutex, 세마포 등의 동기화 도구도 시스템 자원
  - 가장 일반적인 교착 상태의 발원지
- 프로세스의 자원 사용 순서
  1. **요청**: 자원을 요청, 바로 요청이 허용되지 않으면 대기함
  2. **사용**: 자원에 대한 작업을 수행
  3. **방출**: 자원을 방출



## 2. 다중 스레드 응용에서 교착 상태

```
# 스레드1
lock(mutex1)
lock(mutex2)
...
unlock(mutex2)
unlock(mutex1)

# 스레드1
lock(mutex2)
lock(mutex1)
...
unlock(mutex1)
unlock(mutex2)
```

- 스레드1이 mutex1획득, 스레드2가 mutex2를 획득하면 교착상태에 빠짐



#### 1) 라이브락

> 스레드가 실패한 행동을 계속해서 시도할 때 발생

- 예시: 복도에서 한 사람은 오른쪽, 한 사람은 왼쪽으로 움직이면 서로를 방해

  -> 한 사람은 왼쪽, 한 사람은 오른쪽으로 이동하면 여전히 서로를 방해 -> 반복 ...



## 3. 교착 상태 특성

#### 1) 필요조건

1. 상호 배제: 한 번에 한 스레드만이 한 자원을 사용할 수 있다. 다른 스레드가 해당 자원을 요청하면 자원이 방출될 때까지 지연되어야 한다.
2. 점유하며 대기: 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 대기해야한다.
3. 비선점: 자원들을 선점할 수 없어야 한다.
4. 순환 대기: 대기하는 스레드 집합 {T_0, T_1, T_2, ... T_n} 에서 T_0는 T_1이 점유한 자원 대기, T_1은 T_2가 점유한 자원 대기, ... T_n은 T_0가 점유한 자원을 대기한다.

- 교착 상태가 발생하려면 위 4가지 조건을 만족해야 함

