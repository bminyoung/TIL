# Synchronization Tools

> 여러 프로세스가 공유 데이터에 동시에 접근하면 데이터의 일관성을 망친다.
>
> -> 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황(경쟁 상황) 발생

- 프로세스1에서 count++, 프로세스2에서 count-- 를 동시에 실행 (경쟁 상황)

  => count값이 부정확한 상태에 도달

## 1. 임계구역 문제

- 임계구역: 다른 프로세스와의 공유 데이터에 접근, 갱신할 수 있는 부분
  - 동시에 두 프로세스가 임계구역에서 실행할 수 없음
  - 임계구역 진입을 위해 허가를 요청해야 함
- 임계구역 문제: 프로세스 간 데이터 공유를 위해 프로토콜을 설계하는 것
- 프로세스 구조
  - 진입 구역: 코드 중 임계구역 **진입 허가 요청**하는 부분
  - 퇴출 구역
  - 나머지 구역: 나머지 코드 부분

- 임계구역 문제 해결을 위한 요구 조건

  1. **상호 배제**: 한 프로세스가 자신의 임계구역에서 실행되면, 다른 프로세스는 임계구역에서 실행될 수 없음

  2. **진행**: 임계구역에서 실행되는 프로세스가 없고, 진입하려고 하는 프로세스가 있는 경우

     -> 나머지 구역에서 실행 중이지 않은 프로세스만 누가 임계구역으로 진입할 수 있는지 결정에 참여 가능 & 이 선택은 무한정 연기 불가능

  3. **한정된 대기**: 프로세스가 임계구역 진입 요청을 한 후 허용될 때까지, 다른 프로세스가 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 함

- 선점형 커널: 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용
  - 커널 자료구조에서 경쟁 조건이 발생하지 않도록 신중하게 설계되어야 함
- 비선점형 커널: 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용x, 프로세스는 커널을 빠져나가거나, 봉쇄되거나, CPU의 제어를 양보할 때까지 계속 수행됨
  - 커널 자료구조에 대한 경쟁 조건을 염려할 필요x
  - 응답이 더 민첩할 수 있음
  - 실시간 프로세스가 커널에서 실행 중인 프로세스를 선점할 수 있어 실시간 프로그래밍에 더 적합



## 2. Peterson의 해결안

- 상호 배제, 진행, 한정된 대기 의 요구 조건을 중점으로 다루는 소프트웨어 설계에 대한 복잡성을 잘 설명
- 두 프로세스 간에 두 데이터를 공유한다.

```
int turn; //임계구역으로 진입할 순번
boolean flag[2]; //임계구역 진입 준비되었는지 여부
```

- 프로세스0

```
while(true){
	flag[0] = true;
	turn = 1;
	while(flag[1] && turn == 1); //★
	//임계구역
	flag[0] = false;
	...
}
```

- 프로세스1

```while(true){
while(true){
	flag[1] = true;
	turn = 0;
	while(flag[0] && turn == 0); //★
	//임계구역
	flag[1] = false;
	...
}
```

- 프로세스 0,1이 동시에 실행되면 ★ 중 하나만 실행됨 (turn은 0,1 둘 중 하나의 값만 가져서)

- Peterson의 해결안은 3가지를 만족한다.

  1. 상호 배제가 제대로 지켜짐
  2. 진행에 대한 요구 조건 만족
  3. 대기 시간이 한없이 길어지지 않음

- 최신 컴퓨터 아키텍처에서는 작동한다고 보장x

  - 명령어의 순서가 재정렬될 수 있기 때문

  - ```
    turn = 1;
    flag[1] = true;
    // flag에 값이 먼저 대입될 수도 있음
    ```



## 3. 동기화를 위한 하드웨어 지원

#### 1) 메모리 장벽

- 메모리 모델: 메모리 접근 시 보장되는 사항을 결정한 방식 (컴퓨터 아키텍처가 프로그램에게 제공)
  - 강한 순서: 프로세서의 메모리 변경 결과가 다른 프로세서에서 즉시 보임
  - 약한 순서: 프로세서의 메모리 변경 결과가 다른 프로세서에서 즉시 보이지 않음

- `메모리 장벽`: 메모리의 모든 변경 사항을 다른 프로세서로 전파하는 명령어 (메모리 펜스)

  - 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보임

  - 메모리 장벽 실행 전 모든 적재 및 저장이 완료되도록 함

  - ```
    turn = 1;
    memory_barrier();
    flag[1] = true;
    ```

  - 매우 낮은 수준의 연산, 커널 개발자만 사용



#### 2) 하드웨어 명령어

> 워드를 검사, 변경 or 내용을 원자적으로 교환할 수 있는 하드웨어 명령어 제공

- test_and_set

  - ```
    boolean test_and_set(boolean *target);
    ```

  - 인자로 입력한 target값을 return하는 동시에 true값으로 바꿈

  - ```
    lock = false;
    ...
    while(test_and_set(&lock));
    // 임계구역
    lock = false;
    ...
    ```

    1. (프로세스1) lock값(0) 반환, lock=1, while문 패스
    2. (프로세스1) 임계구역 진입
    3. (프로세스2) while검사, lock=1, while 반복
    4. (프로세스1) 임계구역 빠져나옴, lock = false
    5. (프로세스2) 1번부터 반복

- compare_and_swap

  - ```
    int compare_and_swap(int *value, int expected, int new_value);
    ```
    
  - 인자로 입력한 value값을 return하는 동시에 (value==expected)면 value값을 new_value로 바꿈
  
  - ```
    lock = 0;
    ...
    while(compare_and_swap(&lock, 0, 1) != 0);
    // 임계구역
    lock = 0;
    ...
    ```
  
    1. (프로세스1) lock값(0) 반환, lock=1, while문 패스
    2. (프로세스1) 임계구역 진입
    3. (프로세스2) while검사, lock값(1) 반환, while 반복
    4. (프로세스1) 임계구역 빠져나옴, lock = 0
    5. (프로세스2) 1번부터 반복
    
  
- ```
  // 공통 데이터 추가
  boolean waiting[n];
  int lock;
  ```

- <img src="./Image/mutual-exclusion(cas).jpg" alt="mutual-exclusion(cas)" style="zoom:80%;" />

  - 상호배제: `while(waiting[i] && key == 1)`
    - 진입한 프로세스 이후 key값은 항상 1

  - 진행: `if(j == i)` 이하

    - lock 또는 waiting 변수를 변경해 다른 프로세스가 진입하게 함

  - 한정된 대기 조건: `while( (j != i) && !waiting[j])`문

    - 프로세스i 이후 i+1, i+2 ....순서로 준비 상태를 조사

      => 모든 프로세스는 최대 n-1만 양보하면 임계구역 진입

#### 3) 원자적 변수

- 정수 및 부울과 같은 **기본 데이터 유형**에 대한 원자적 연산을 제공



## 4. Mutex Locks

- 임계구역 진입 시 mutex 락을 **획득**해야 하며 빠져나갈 때 mutex 락을 **반환**해야함

- available라 불리는 변수를 가짐 (=락의 가용 여부)
  - 획득, 반환 함수 = available 값 사용, 원자적으로 수행되어야 함

- 획득 함수에서 available 값을 검사하며 while문이 계속 수행됨 => 바쁜 대기
  - 반복문을 계속 수행하면서 CPU 주기를 낭비
- Mutex 락 유형을 **스핀락** 이라고 한다. (락이 가용 상태가 될 때까지 프로세스가 회전하기 때문)



## 5. 세마포

> 세마포 S = 정수 변수
>
> 원자적 연산 wait(), signal() 로만 접근 가능



#### 1) 세마포 사용법

- 이진 세마포: 0~1 값만 가능, mutex 락과 유사하게 동작

- 카운팅 세마포: 유한개의 자원에 대한 접근 제어 가능

  - 자원 사용 -> 세마포--
  - 자원 반환 -> 세마포++
  - (세마포==0) => 모든 자원 사용 중, 세마포값이 0보다 커질 때까지 프로세스 봉쇄

- 응용 예

  ```
  # 프로세스1
  S1;
  signal(synch);
  
  # 프로세스2
  wait(synch);
  S2;
  ```

  - 세마포 synch를 공유, 초기값이 0이기 때문에 S1이 실행된 후 S2가 실행될 수 있다.



#### 2) 세마포 구현

- 세마포값이 양수가 아니면 프로세스 대기 (바쁜 대기x)

  => 프로세스를 대기 큐에 넣고 signal 실행 시 wakeup() 연산으로 준비완료 상태로 변경

- 세마포는 원자적으로 실행되어야 함

- 같은 세마포에 대한 여러 프로세스에서 wait, signal을 동시에 실행할 수 없어야 함



## 6. 모니터

- 세마포 사용 시 문제가 발생할 수 있음 (프로그래밍 오류 or 개발자의 실수)
  1. signal, wait 순서가 바뀜 (상호 배제 위반)
  2. wait, wait 호출 (2번째 wait에서 영구봉쇄)
  3. wait 또는 signal 빠뜨림
- 오류 해결을 위한 방법 중 하나: 고급 언어 구조물 제공



#### 1) 모니터 사용법

- ADT(Abstract Data Type): 데이터 & 데이터를 조작하는 함수들의 집합
- **모니터 형**: 모니터 내부에서 상호 배제가 보장되는, 개발자가 정의한 ADT
  - cf) ADT = class, 모니터 = 사용자 정의 클래스
- 하나의 프로세스만 활성화되도록 보장해 줌
- 부가적인 동기화 기법: 조건 변수
  - 조건 변수 x의 연산: wait, signal
  - x.wait: 다른 프로세스가 x.signal을 호출할 때까지 프로세스 대기
  - x.signal: 하나의 일시 중지된 프로세스 재개



#### 2) 모니터 내 프로세스 재개

>  x.signal() 수행 시 어떤 프로세스를 수행 재개 시킬 것인가

- FCFS
- conditional-wait
  - x.wait(c) - c(우선순위 번호)
  - 작은 우선순위 번호를 가진 프로세스가 수행 재개

