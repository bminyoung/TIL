# Synchronization Tools

> 여러 프로세스가 공유 데이터에 동시에 접근하면 데이터의 일관성을 망친다.
>
> -> 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황(경쟁 상황) 발생



## 1. 임계구역 문제

- 임계구역: 다른 프로세스와의 공유 데이터에 접근, 갱신할 수 있는 부분
  - 동시에 두 프로세스가 임계구역에서 실행할 수 없음
  - 임계구역 진입을 위해 허가를 요청해야 함
- 임계구역 문제: 프로세스 간 데이터 공유를 위해 프로토콜을 설계하는 것
- 프로세스 구조
  - 진입 구역: 코드 중 임계구역 **진입 허가 요청**하는 부분
  - 퇴출 구역
  - 나머지 구역: 나머지 코드 부분

- 임계구역 문제 해결을 위한 요구 조건

  1. **상호 배제**: 한 프로세스가 자신의 임계구역에서 실행되면, 다른 프로세스는 임계구역에서 실행될 수 없음

  2. **진행**: 임계구역에서 실행되는 프로세스가 없고, 진입하려고 하는 프로세스가 있는 경우

     -> 나머지 구역에서 실행 중이지 않은 프로세스만 누가 임계구역으로 진입할 수 있는지 결정에 참여 가능 & 이 선택은 무한정 연기 불가능

  3. **한정된 대기**: 프로세스가 임계구역 진입 요청을 한 후 허용될 때까지, 다른 프로세스가 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 함

- 선점형 커널: 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용
  - 커널 자료구조에서 경쟁 조건이 발생하지 않도록 신중하게 설계되어야 함
- 비선점형 커널: 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용x, 프로세스는 커널을 빠져나가거나, 봉쇄되거나, CPU의 제어를 양보할 때까지 계속 수행됨
  - 커널 자료구조에 대한 경쟁 조건을 염려할 필요x
  - 응답이 더 민첩할 수 있음
  - 실시간 프로세스가 커널에서 실행 중인 프로세스를 선점할 수 있어 실시간 프로그래밍에 더 적합



## 2. Peterson의 해결안

- 상호 배제, 진행, 한정된 대기 의 요구 조건을 중점으로 다루는 소프트웨어 설계에 대한 복잡성을 잘 설명
- 두 프로세스 간에 두 데이터를 공유한다.

```
int turn; //임계구역으로 진입할 순번
boolean flag[2]; //임계구역 진입 준비되었는지 여부
```

- 프로세스0

```
while(true){
	flag[0] = true;
	turn = 1;
	while(flag[1] && turn == 1); //★
	//임계구역
	flag[0] = false;
	...
}
```

- 프로세스1

```while(true){
while(true){
	flag[1] = true;
	turn = 0;
	while(flag[0] && turn == 0); //★
	//임계구역
	flag[1] = false;
	...
}
```

- 프로세스 0,1이 동시에 실행되면 ★ 중 하나만 실행됨 (turn은 0,1 둘 중 하나의 값만 가져서)

- Peterson의 해결안은 3가지를 만족한다.

  1. 상호 배제가 제대로 지켜짐
  2. 진행에 대한 요구 조건 만족
  3. 대기 시간이 한없이 길어지지 않음

- 최신 컴퓨터 아키텍처에서는 작동한다고 보장x

  - 명령어의 순서가 재정렬될 수 있기 때문

  - ```
    turn = 1;
    flag[1] = true;
    // flag에 값이 먼저 대입될 수도 있음
    ```



## 3. 동기화를 위한 하드웨어 지원

#### 1) 메모리 장벽

- 메모리 모델: 메모리 접근 시 보장되는 사항을 결정한 방식 (컴퓨터 아키텍처가 프로그램에게 제공)
  - 강한 순서: 프로세서의 메모리 변경 결과가 다른 프로세서에서 즉시 보임
  - 약한 순서: 프로세서의 메모리 변경 결과가 다른 프로세서에서 즉시 보이지 않음

- `메모리 장벽`: 메모리의 모든 변경 사항을 다른 프로세서로 전파하는 명령어 (메모리 펜스)

  - 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보임

  - 메모리 장벽 실행 전 모든 적재 및 저장이 완료되도록 함

  - ```
    turn = 1;
    memory_barrier();
    flag[1] = true;
    ```

  - 매우 낮은 수준의 연산, 커널 개발자만 사용



#### 2) 하드웨어 명령어

> 워드를 검사, 변경 or 내용을 원자적으로 교환할 수 있는 하드웨어 명령어 제공

- test_and_set

  - ```
    boolean test_and_set(boolean *target);
    ```

  - 인자로 입력한 target값을 return하는 동시에 true값으로 바꿈

  - ```
    lock = false;
    ...
    while(test_and_set(&lock));
    // 임계구역
    lock = false;
    ...
    ```

    1. (프로세스1) lock값(0) 반환, lock=1, while문 패스
    2. (프로세스1) 임계구역 진입
    3. (프로세스2) while검사, lock=1, while 반복
    4. (프로세스1) 임계구역 빠져나옴, lock = false
    5. (프로세스2) 1번부터 반복

- compare_and_swap

  - ```
    int compare_and_swap(int *value, int expected, int new_value);
    ```
    
  - 인자로 입력한 value값을 return하는 동시에 (value==expected)면 value값을 new_value로 바꿈
  
  - ```
    lock = 0;
    ...
    while(compare_and_swap(&lock, 0, 1) != 0);
    // 임계구역
    lock = 0;
    ...
    ```
  
    1. (프로세스1) lock값(0) 반환, lock=1, while문 패스
    2. (프로세스1) 임계구역 진입
    3. (프로세스2) while검사, lock값(1) 반환, while 반복
    4. (프로세스1) 임계구역 빠져나옴, lock = 0
    5. (프로세스2) 1번부터 반복
    
  
- ```
  // 공통 데이터 추가
  boolean waiting[n];
  int lock;
  ```

- <img src="./Image/mutual-exclusion(cas).jpg" alt="mutual-exclusion(cas)" style="zoom:80%;" />

  - 상호배제: `while(waiting[i] && key == 1)`
    - 진입한 프로세스 이후 key값은 항상 1

  - 진행: `if(j == i)` 이하

    - lock 또는 waiting 변수를 변경해 다른 프로세스가 진입하게 함

  - 한정된 대기 조건: `while( (j != i) && !waiting[j])`문

    - 프로세스i 이후 i+1, i+2 ....순서로 준비 상태를 조사

      => 모든 프로세스는 최대 n-1만 양보하면 임계구역 진입